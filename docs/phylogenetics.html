<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Brian O’Meara - Phylogenetics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./logo.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Brian O’Meara</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-cv-etc." role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">CV, etc.</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-cv-etc.">    
        <li>
    <a class="dropdown-item" href="./cv.html">
 <span class="dropdown-text">CV</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./calendar.html">
 <span class="dropdown-text">Calendar</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./feedback.html">
 <span class="dropdown-text">Feedback</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./useful.html">
 <span class="dropdown-text">Useful links</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./tenure.html">
 <span class="dropdown-text">Materials for promotion to associate (and tenure)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./promotion.html">
 <span class="dropdown-text">Materials for promotion to full</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./SSB.html">
 <span class="dropdown-text">Candidacy for SSB president</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./evol2023.html">
 <span class="dropdown-text">SSB Presidential Address 2023</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-lab" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Lab</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-lab">    
        <li>
    <a class="dropdown-item" href="./personnel.html">
 <span class="dropdown-text">People</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./guidelines.html">
 <span class="dropdown-text">Guidelines &amp; Recommendations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./location.html">
 <span class="dropdown-text">Location/Contact</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./opportunities.html">
 <span class="dropdown-text">Opportunities</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./learningobjectives.html">
 <span class="dropdown-text">Learning objectives</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./better-letter.html">
 <span class="dropdown-text">BetterLetter</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./shouldyougotogradschool.html">
 <span class="dropdown-text">Should you go to grad school to be a professor?</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./tenure.html">
 <span class="dropdown-text">Materials for promotion to associate (and tenure)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./promotion.html">
 <span class="dropdown-text">Materials for promotion to full</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./general.html">
 <span class="dropdown-text">Info for general public</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./covid.html">
 <span class="dropdown-text">COVID</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./schedule.html">
 <span class="dropdown-text">EEB scheduling</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teaching" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Teaching</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teaching">    
        <li>
    <a class="dropdown-item" href="./teaching.html">
 <span class="dropdown-text">Teaching overall</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./eeb464.html">
 <span class="dropdown-text">Macroevolution (EEB464)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://phylometh.info/">
 <span class="dropdown-text">Phylogenetic Methods</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-tutorials" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Tutorials</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-tutorials">    
        <li>
    <a class="dropdown-item" href="./aic.html">
 <span class="dropdown-text">AIC</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./phylogenetics.html">
 <span class="dropdown-text">Phylogenetics</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-blog" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Blog</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-blog">    
        <li>
    <a class="dropdown-item" href="./blog.html">
 <span class="dropdown-text">Blog</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./blog.xml">
 <span class="dropdown-text">RSS feed</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Phylogenetics</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Phylogenetic analysis</p>
<p>Each item includes PAUP batch files or commands where appropriate. I wrote this page for the Farrell Lab website, but have included it here as well, where I continue to update it (occasionally). This page is mostly useful for the batch files which are on it. Some useful references which provide broader overviews of phylogenetics are <em><a href="https://www.sinauer.com/Titles/Text/3115.html">Phylogenetic Trees Made Easy</a></em> by Barry Hall, chapters 11 and 12 of the somewhat dated (1996) <em><a href="https://www.sinauer.com/Titles/frhillis.htm">Molecular Systematics, 2nd Edition</a></em>, edited by David Hillis, Craig Moritz, and Barbara Mable, and the recently updated <a href="https://www.bioinf.org/molsys/index.html">Molecular Systematics</a> website. A great new resource is Joe Felsenstein’s new book <em><a href="https://www.sinauer.com/detail.php?id=1775">Inferring Phylogenies</a></em>. You may also check my page of <a href="https://www.brianomeara.info/books.html">books for phylogenetics</a>. PAUP also has a <a href="https://paup.csit.fsu.edu/downl.html#Anchor-58521">quick start tutorial</a> on its <a href="https://paup.csit.fsu.edu/">web page</a> as well as a useful <a href="https://pauptech.si.edu/%7Epaupforum/">discussion group</a> for asking questions. This page was last updated on February 3, 2004 , though most of its information has not been updated since June 10, 2002.</p>
<p>If you find this page useful, and think it may be useful to others, please link to it from your website. This will rank it higher in search engines, making it easier for others to find. Thanks!</p>
<p>Each step listed individually</p>
<p>NEXUS file preparation</p>
<p>Batch files</p>
<p>Exhaustive and branch-and-bound searches (&lt;13 taxa)</p>
<p>Heuristic searches</p>
<p>Parsimony ratchet</p>
<p>Bootstrap searches</p>
<p>Decay indices, including partitioned Bremer support</p>
<p><a href="phylogenetics.html#likelihood">Choosing a likelihood model</a></p>
<p>Testing for a molecular clock</p>
<p>Calibrating using a published calibration</p>
<p>Calibrating using fossil data</p>
<p>Computing error bars on node times</p>
<p>Bayesian searches (MrBayes)</p>
<p>Hypothesis testing</p>
<p>Tree drawing and editing</p>
<p>NEXUS file preparation</p>
<ol type="1">
<li><p>Open the NEXUS file with <a href="https://phylogeny.arizona.edu/macclade/macclade.html">MacClade</a> 4.03 or higher.</p></li>
<li><p>Select characters for one locus by shift-clicking on characters for that locus.</p></li>
<li><p>Under the Characters menu, choose “Character Set…” then “Store Character Set”.</p></li>
<li><p>Name this set by the name of the locus (omit spaces)</p></li>
<li><p>Do the same for other loci.</p></li>
<li><p>Make sure that the genetic code is correct for your loci by going to “Genetic Code…” in the Characters menu. For mixed nuclear and mitochondrial loci, choose <em>Drosophila</em> mtDNA.</p></li>
<li><p>For protein-coding loci, select all the characters in one exon, then go to Characters -&gt; “Codon Positions” -&gt; “Calculate Positions…”. Select the option “Choose to minimize stop codons”.</p></li>
<li><p>Select non-protein-coding regions (i.e., introns, rDNA) and go to Characters -&gt; “Codon Positions” -&gt; “Non-coding”.</p></li>
<li><p>Go to Taxa -&gt; “Taxon list”.</p></li>
<li><p>Move the outgroup taxa so that they are next to each other by dragging the number to the left of the taxon name.</p></li>
<li><p>Select the whole group of outgroup taxa by shift-clicking on their numbers.</p></li>
<li><p>Go to Taxa -&gt; “Taxon sets” -&gt; “Store taxon set”.</p></li>
<li><p>Name this taxon set “outgroup”.</p></li>
<li><p>Do the same for other taxa you would like in a set. Feel free to change the order of the taxa to do this.</p></li>
<li><p>When you are done, click on the icon that looks like a Mayan pyramid, then click on one of the taxa. This alphabetizes the taxa, making later steps in PAUP easier.</p></li>
<li><p>Go to File -&gt; “Print list” to print the list, along with taxon numbers.</p></li>
<li><p>Save the file and quit MacClade.</p></li>
<li><p>Open PAUP 4.0b8 or higher. PAUP often has updates, so check its <a href="https://paup.csit.fsu.edu/">website</a> to make sure you are using a recent version. Also check for <a href="https://paup.csit.fsu.edu/problems.html">bug reports</a>.</p></li>
<li><p>From within PAUP, open the file you just saved with MacClade. Choose “Edit”, not “Execute”.</p></li>
<li><p>Scroll down to below the data matrix.</p></li>
<li><p>NEXUS files are arranged in blocks, starting with “BEGIN ###;” and ending with “END;”. Go to the SETS block [skip this and the next 2 instructions if you have only one locus or no coding regions].</p></li>
<li><p>Start a new line. Type “CHARSET”, a space, then “###first =”, replacing ### with the name of your first coding locus.</p></li>
<li><p>Look for the CODONS block. You should see something within this block that looks like “1: 1-1300\3 1400-2700\3”, with the numbers changed. If your first coding locus is 1302 long, for example, copy the “1-1300\3”and place it after the equals sign in the line you just created. If your first coding locus extends all the way to 2700 in this example, just with an intron in the middle, copy the entire “1-1300\3 1400-2700\3” to after the equals sign in the line you just created.</p></li>
<li><p>Type a semicolon at the end of this line after pasting in the numbers.</p></li>
<li><p>You have just created a character set containing all the bases with the first codon position from your first coding locus. Repeat the same process for other loci, all three positions. The general format is “CHARSET [charset name] = [character numbers];”.</p></li>
<li><p>You can do the same thing with sets of taxa. You should already have a taxset named “outgroup”. You can make other taxsets using the format “TAXSET [taxset name] = [taxon numbers];”. The taxon number is the same as the number on the taxon’s left in MacClade’s taxon list window, which you have printed out. It’s also the order of taxa within the DATA block.</p></li>
<li><p>Create a PAUP block. Make sure this is after one of the “end;” lines but before the next “Begin ###;” lines. The format is “Begin PAUP;” skip a few lines, then “end;”. Don’t forget the semicolons.</p></li>
<li><p>Within the PAUP block, create a character partition. The general format is “CHARPARTITION [partition name] = [charset name 1]:[charset name 1], [charset name 2]:[charset name 2], [charset name 3]:[charset name 3];” For example, if the data consists of 28S and COI sequence, you would have a charset called 28s, another charset called coI, and the charparition command would be “CHARPARTITION locus = 28s:28s, coI:coI;” This is used in ILD tests.</p></li>
<li><p>Within the PAUP block, paste the following text:</p></li>
</ol>
<p>outgroup outgroup /only; set maxtrees=5000 increase=auto autoclose=no torder=right tcompress=yes taxlabels=full storebrlens=yes storetreewts=yes outroot=paraphyl;</p>
<p>This sets the outgroup to be whatever you determined in the outgroup taxset, sets a reasonable starting maxtrees number, and sets other PAUP preferences to useful ones for starting a search. Other PAUP commands can be included in the PAUP block as well.</p>
<ol start="30" type="1">
<li>You may find it useful to keep a running log of all analyses done. This can be helpful in checking what p-values were of various tests, how many replicates were done in a particular search, etc. To do this, paste the following text within the PAUP block:</li>
</ol>
<p>log file=[name] append=yes replace=no;</p>
<p>If you do this, delete the log commands from other batch files (see below) so that everything is logged to one file.</p>
<p>Batch files</p>
<p>Batch files are ways to give PAUP commands without going through the menus (Mac) or entering items one at a time in the command line (all platforms). For example, you could set up a PAUP batch file which would do a heuristic search saving the best trees from each addition sequence replicate, save these trees to a file, filter for the best trees, and finally save these best trees to a second tree file. Batch files are also a good way to ensure consistency between searches – for example. you won’t have to remember if you used 5 or 10 addition sequence replicates per bootstrap replicate, as that information will be in the batch file. A batch file has the following format:</p>
<p>#nexus [Tells PAUP that this is a NEXUS file]</p>
<p>begin PAUP; [Starts the PAUP block]</p>
<p><em>[PAUP commands]</em>; [Gives PAUP instructions on what to do – the same thing you enter in the command line]</p>
<p>end; [Ends the PAUP block]</p>
<p>To create a batch file, first create a new document within PAUP or in some other text editor (such as SimpleText). Then type “#nexus” in the first line and “begin paup;” in the second. After that, include the PAUP commands you want – PAUP’s command reference document, available from the <a href="https://paup.csit.fsu.edu/downl.html">downloads</a> section of its <a href="https://paup.csit.fsu.edu/">website</a>, is invaluable in constructing these. Finally, write “end;” at the end of the document. Save the document. Now, executing the document, the same way you execute a data file, will start the commands running.</p>
<p>All the batch files on this website can be copied into a new PAUP document and executed. Several of the batch files have places to insert the name of a file or set, often appearing as [name]. Make sure that the brackets are removed: for example, if the file is called tree1, “file=[name]” should become “file=tree1”. PAUP makes batch file troubleshooting easy – if there is a problem with the file, PAUP will open the file and put the cursor where the error occured. PAUP does not see anything in brackets, so comments written there will not affect analyses. The only two exceptions to this are: 1) if the first character within the bracket is an exclamation point, PAUP will display the contents in the display buffer; and 2) Trees can have a [&amp;U] or [&amp;R] to tell PAUP if they are rooted or not.</p>
<p>Exhaustive and branch-and-bound searches (&lt;13 taxa)</p>
<p>Both these search strategies are guaranteed to find the optimal tree. However, they are not generally practical for even moderate numbers of taxa: finding the best tree is generally an <a href="https://en.wikipedia.org/wiki/NP-hard">NP-hard</a>problem. Thus, heuristic searches are necessary for most analyses.</p>
<p>Heuristic searches</p>
<p>Heuristic searches are not guaranteed to find the globally-optimal tree, but they can work for many more taxa than exhaustive or branch-and-bound searches. A good starting batch file is:</p>
<blockquote class="blockquote">
<blockquote class="blockquote">
<p>#nexus</p>
</blockquote>
<p>begin PAUP;</p>
<p>log file=hsearch1.log;</p>
<p>set autoclose=yes;</p>
<p>hsearch start=stepwise addseq=random nreps=<strong>100</strong> savereps=yes randomize=addseq rstatus=yes hold=1 swap=tbr multrees=yes;</p>
<p>savetrees file=hsearch1.all.tre brlen=yes;</p>
<p>filter best=yes permdel=yes;</p>
<p>savetrees file=hsearch1.best.tre brlen=yes;</p>
<p>log stop;</p>
end; &gt; &gt;
</blockquote>
<p>This batch file will do a heuristic search, save all the trees found in each random addition sequence replicate in the hsearch1.all.tre file, then filter for the best trees overall and save them in an hsearch1.best.tre file. PAUP will also output a tree-island profile. A “tree-island” is a group of trees which cannot be reached through branchswapping from a different group of trees. Ideally, all the trees will be on one island which will have been hit every time, no matter what starting tree or taxon addition order. If this is the case, the treespace is fairly simple and we would probably move on to bootstrapping. If the island(s) with the best trees was hit nearly all the time, we’d probably be satisfied, as well. However, if the best trees are not recovered in many of the searches, we would need to search further.</p>
<p>We use a variety of strategies for these next searches. The first strategy is to simply increase the number of addition sequence replicates. To do this, change the nreps=100 in the batch file above to a higher number, perhaps nreps=1000. To avoid confusion, we may also want to replace “hsearch1” with “hsearch2” wherever it appears before running the search again.</p>
<p>Another strategy is to start from random trees, rather than random taxon addition. On the above batch file, change the randomize=addseq to randomize=trees, change the “hsearch#” as above, and search again, with nreps to taste.</p>
<p>These searches will run longer than the initial search. A way to speed up the search while covering more of tree space is to increase the number of addition replicates but reducing the thoroughness of the search for each replicate. We might do this if we believe there may be islands of good trees PAUP is missing. A sample batch file follows. You may want to change the nreps and timelimit.</p>
<blockquote class="blockquote">
<blockquote class="blockquote">

</blockquote>
<blockquote class="blockquote">
<p>#nexus</p>
</blockquote>
<p>begin paup;</p>
<p>log file=hsearch.tlimit.log;</p>
<p>set maxtrees=10000 increase=auto;</p>
<p>hsearch rstatus=no limitperrep=yes nreps=5000 randomize=trees timelimit=5 savereps=yes;</p>
<p>savetrees file=hsearch.tlimit.all.tre brlen=yes;</p>
<p>filter best=yes permdel=yes;</p>
<p>savetrees file=hsearch.tlimit.best.tre brlen=yes;</p>
<p>end; &gt; &gt;</p>
<blockquote class="blockquote">

</blockquote>
</blockquote>
<p>The parsimony ratchet (below) can be useful in searching treespace broadly, as well.</p>
<p>Parsimony ratchet</p>
<p>The parsimony ratchet is a way to search treespace by reweights characters for some iterations of a search. It is especially good for searches with large numbers of taxa. It is described by Kevin Nixon (Nixon, K. C. 1999. “The Parsimony Ratchet, a new method for rapid parsimony analysis.” <em>Cladistics</em> 15: 407-414). Derek Sikes and Paul Lewis have written a program, called <a href="https://viceroy.eeb.uconn.edu/paupratweb/pauprat.htm">PaupRat</a>, which generates batch files to implement this search strategy in PAUP. A few notes on the use of this: 1) It’s better to do several searches of a moderate number of nreps in each search (create a new ratchet file for each search) than one search with many nreps; 2) It’s useful to insert the commands:</p>
<blockquote class="blockquote">
<p>stopcmd “filter best=yes permdel=yes”;</p>
stopcmd “savetrees file=mydata.best.tre”;
</blockquote>
<p>into the setup.nex file before the stopcmd “[quit]”; to automatically filter for the best trees.</p>
<p>Bootstrap searches</p>
<p>Bootstrap searches can take quite some time. One useful feature of PAUP is the ability to search on multiple computers or on several different occasions and combine the results. The key to this is saving the bootstrap trees from each search and then loading them all together, then computing the consensus tree using the tree weights. You must be sure to keep the bootstrap search settings (except for the number of bootstrap replicates) the same between searches for this to be valid. This can be done through the menus (make sure to hit the “save trees to file” checkbox in the bootstrap menu), or through the batch files (below).</p>
<p>For the search itself [the search can be stopped before completing all the bootstrap replicates; if doing multiple searches, the treefile name should be changed for each search. You may want to change the number of bootstrap replicates (currently set at 500) and the number of random taxon additions per bootstrap replicate (currently set at a low value of 10)]:</p>
<blockquote class="blockquote">
<p>#nexus</p>
<p>begin paup;</p>
<p>set storetreewts=yes;</p>
<p>bootstrap nreps=<strong>500</strong> treefile=bootstrap1.tre replace=no brlen=yes/ start=stepwise addseq=random nreps=<strong>10</strong> savereps=no randomize=addseq hold=1 swap=tbr multrees=yes;</p>
end;
</blockquote>
<p>Load all the bootstrap trees, making sure to store tree weights (an option which should have been made the default by the above batch file), to load all blocks, and NOT to eliminate duplicate trees. Executing the following batch file should set all these options and load the trees saved as bootstrap1.tre in the active folder.</p>
<blockquote class="blockquote">
<p>#nexus</p>
<p>begin paup;</p>
<p>gettrees allblocks=yes duptrees=keep storetreewts=yes storebrlens=yes mode=7 file=bootstrap1.tre;</p>
end;
</blockquote>
<p>Finally, compute a majority-rule consensus tree. The batch file for this is:</p>
<blockquote class="blockquote">
<blockquote class="blockquote">

</blockquote>
<blockquote class="blockquote">
<p>#nexus</p>
</blockquote>
<p>begin paup;</p>
<p>log file=bootstrapconsensus.log;</p>
<p>contree /majrule=yes strict=no le50=yes usetreewts=yes showtree=yes treefile=finalbootstrap.tre grpfreq=yes;</p>
<p>log stop;</p>
<p>end; &gt; &gt;</p>
<blockquote class="blockquote">

</blockquote>
</blockquote>
<p>Note that this will create a bootstrap tree which will include nodes with support less than 50% which are consistent with the majority rule tree. Most authors choose to omit bootstrap numbers less than 50% while continuing to show the node; a better approach, if space allows, would be to show all bootstrap values.</p>
<p>Though likelihood is far slower than parsimony, this does not mean that likelihood is too slow for bootstrapping. To speed up likelihood bootstrap searches, one can fix the values of nuisance parameters (for example, use the lset output from ModelTest) and time limit each heuristic search.</p>
<blockquote class="blockquote">
<blockquote class="blockquote">

</blockquote>
<blockquote class="blockquote">
<blockquote class="blockquote">
</blockquote>
<blockquote class="blockquote">
<blockquote class="blockquote">

</blockquote>
</blockquote>
</blockquote>
<blockquote class="blockquote">

</blockquote>
<blockquote class="blockquote">
</blockquote>
</blockquote>
<p>Decay indices, including partitioned Bremer support</p>
<p>For simple decay indices, <a href="https://www.macclade.org/">MacClade</a> can generate a batch file. Go to the tree window, then go to the sigma (<img src="../icons/sigma.gif" class="img-fluid">) menu -&gt; “Decay Index Paup File…”. For partitioned Bremer support, we use <a href="https://mightyduck.bu.edu/TreeRot/index.html">TreeRot</a> (see its detailed instruction manual).</p>
<p>Choosing a likelihood model</p>
<p>We generally use David Posada’s program <a href="https://bioag.byu.edu/zoology/crandall_lab/modeltest.htm">ModelTest</a> to determine the appropriate likelihood model. This consists of a batch file which has PAUP compute the likelihood score of a tree under various models and a program which computes the likelihood ratio test and the AIC criterion. When the two criteria choose different models, we use the likelihood ratio test result. This procedure will be brought into PAUP in one of the next updates, according to PAUP’s programmers.</p>
<p>Testing for a molecular clock</p>
<p>Once the appropriate likelihood model has been selected by ModelTest, one can test for a clock. Copy the lscores line corresponding to ModelTest’s chosen model from the modelblock file and paste this over the [LSCORES] lines in the following batch file:</p>
<blockquote class="blockquote">
<blockquote class="blockquote">
<p>#nexus</p>
</blockquote>
<p>begin paup;</p>
<p>set criterion=distance;</p>
<p>log file=clocktest.log;</p>
<p>DSet distance=JC objective=ME base=equal rates=equal pinv=0</p>
<p>subst=all negbrlen=setzero;</p>
<p>NJ showtree=no breakties=random;</p>
<p>set criterion=likelihood;</p>
<p>lset clock=no;</p>
<p>[LSCORES];</p>
<p>;[!Non-clock score above, clock score below];</p>
<p>roottrees;</p>
<p>lset clock=yes;</p>
<p>[LSCORES];</p>
<p>;[!Clock score above];</p>
<p>tstatus;</p>
<p>log stop;</p>
end; &gt; &gt;
</blockquote>
<p>This will result in two ln likelihood scores. Take the difference between the scores and double it. This is your test statistic for a chi-squared test; the number of taxa minus 2 is the degrees of freedom. You can use a program such as Microsoft Excel (the chidist function) or <a href="https://www.fon.hum.uva.nl/Service/Statistics/ChiSquare_distribution.html">this web site</a> to compute the p-value. Significant p-values mean that the clock is rejected. People generally try each locus independently; if you have time, you could use ModelTest to determine the correct likelihood model for each locus, or just use the model chosen for all the loci combined.</p>
<p>Calibrating the tree I: Using a previously-published calibration</p>
<p>There are generally two ways to put ages on nodes of a clock tree: 1) Use a previously-published rate of percent divergence for a particular gene versus time, or 2) Use fossil information (see next entry). Reported calibration rates often are in terms of uncorrected percent sequence divergence per million years (“uncorrected” means uncorrected for multiple hits). To use this value for your tree, compute all uncorrected pairwise distances for your taxa in PAUP. With menus, use File -&gt; Save Distances to File, then Options -&gt; Distance options and select uncorrected “p”. The batch file would be (replacing [filename] with what you want to call the distance file, without brackets):</p>
<blockquote class="blockquote">
<blockquote class="blockquote">
<p>#nexus</p>
</blockquote>
<p>begin paup;</p>
<p>dset distance=p;</p>
<p>savedist format=onecolumn file=[filename] undefined=asterisk;</p>
end; &gt; &gt;
</blockquote>
<p>Examine the ensuing list (in PAUP or Microsoft Excel) to find a pair of taxa which have a percent divergence similar to the ones in the taxa used in the original calibration. Using these taxa, rather than the oldest or youngest pair, makes it more likely that the proportion of uncorrected multiple hits will be the same for the calibration and the pair being used to calibrate the entire tree (the rate of uncorrected divergence versus time will go down with time as multiple hits accumulate). The calibration rate can be used to determine the age of the node separating the chosen pair of taxa. The age of the node is then used to calibrate the rest of the tree.</p>
<p>Calibrating the tree II: Using fossil data</p>
<p>The rate of molecular evolution may be affected by many things: mutation rate, generation time, and perhaps even body size. A calibration based on fossil data of the group being studied may be more accurate than a calibration from other organisms. Multiple calibration points will give the most precise estimate. Record infomation about all the fossils in the group, not just the oldest. Fossils tend to give just minimum ages for the group – think about ways to determine maximum ages, as well. For example, the group may not be older than the evolution of life on land, or may not be older than the oldest possible age (which is not the age of the oldest known fossil) of an obligate host. Biogeographic information may also be useful. Fossil calibrations, and minimum ages in general, should be mapped to the stem of the clade (= the most recent common ancestor of the clade and its sister group). . Maximum ages should be mapped to the most recent common ancestor (MRCA) of the clade constrained by that calibration (the “crown”). For example, if we have a calibration for birds using the oldest known bird fossil (a minimum age constraint), we know that the split between birds and their sister group had to happen eariler than that fossil, but not that the MRCA of the bird taxa included in our study lived before that fossil. In contrast, if we say that we know that Lepidoptera must have evolved after the first terrestrial plants (a maximum age constraint), we know that the MRCA of Lepidoptera cannot be older than that, but not that the split separating Lepidoptera from their sister group occurred after it. The total branchlength from the present to the node of each constraint on the clock tree is recorded (the units do not matter, as long as the branch lengths are proportional to time). This information, plus the age and type of the calibration constraint, are entered into an Excel sheet which calculated the maximum and minimum possible rates given all the calibration points. This can easily be done manually, as well. Each branch length is then multiplied by these rates to get the maximum and minimum length of the branch in time. Note that the rate is actually applied to the whole tree at once – the tree is stretched or compressed by the maximum or minimum rates – the ratio of the ages of nodes does not change with the different rates. Other methods must be used to calculate error bars on the ages of nodes due to finite sequence length rather than uncertain calibration. These methods are explained below.</p>
<p>Determining error bars on ages of nodes</p>
<p>For determining error bars on nodes, two methods can be used, both implemented in Sanderson’s <a href="https://ginger.ucdavis.edu/r8s/">r8s</a> program. The first method involves looking at the shape of the likelihood surface. The second method uses bootstrapped datasets and calculates error bars from the distribution of branchlengths on the bootstrapped dataset. We have done the latter method using PAUP and Excel, due to a lack of Linux x86 computers to run r8s. First, <a href="https://evolution.genetics.washington.edu/phylip.html">Phylip</a>’s SeqBoot is used to create bootstrapped datasets. These are edited in PAUP to merge them into one large dataset (for example, if the original dataset is 3000 characters long, and 500 bootstrap replicate datasets are created, they are edited to make a single 1,500,000 character dataset. A PAUP batch file is then constructed in Excel which divides the combined datasets into character sets and then has PAUP evaluate the branchlengths of the given topology (the clock tree being evaluated) for each replicate dataset (corresponding to a charset). A sample batch file is below for a dataset 2432 characters long. Some of the repetitive commands have been deleted, but the pattern should be clear. Before executing this batch file, load your long datafile, set the likelihood parameters, and load your clock tree.</p>
<blockquote class="blockquote">
<blockquote class="blockquote">
<p>#nexus</p>
</blockquote>
<p>begin paup;</p>
<p>charset rep1 = 1 - 2432 ;</p>
<p>charset rep2 = 2433 - 4864 ;</p>
<p>charset rep3 = 4865 - 7296 ;</p>
<p>_[…. repetitive commands not included here. Just use Excel to follow the pattern….]</p>
<p>_charset rep500 = 1213569 - 1216000 ;</p>
<p>exclude all;</p>
<p>include rep1 ; [! rep 1 ]</p>
<p>savetrees root=yes brlen=yes maxdecimals=6 replace=no append=yes file=brlenwbootstrapdata.tre;</p>
<p>exclude all;</p>
<p>include rep2 ; [! rep 2 ]</p>
<p>savetrees root=yes brlen=yes maxdecimals=6 replace=no append=yes file=brlenwbootstrapdata.tre;</p>
<p>exclude all;</p>
<p>include rep3 ; [! rep 3 ]</p>
<p>savetrees root=yes brlen=yes maxdecimals=6 replace=no append=yes file=brlenwbootstrapdata.tre;</p>
<p><em>[…. repetitive commands not included here. Just use Excel to follow the pattern….]</em></p>
<p>exclude all;</p>
<p>include rep500 ; [! rep 500 ]</p>
<p>savetrees root=yes brlen=yes maxdecimals=6 replace=no append=yes file=brlenwbootstrapdata.tre;</p>
end; &gt; &gt;
</blockquote>
<p>The trees are all saved in one file with branchlengths by PAUP. This tree file is then opened within Excel, with the length of each branch put in a column. The total length of branches from the root to the node of interest is computed for each tree and divided by the distance from the root to the tips. Then the percentile function is used in Microsoft Excel to determine the 95% confidence interval on the distance from the root to the node of interest, with the distance expressed as proportion of total tree length.</p>
<p>Bayesian searches (MrBayes)</p>
<p>Bayesian phylogenetic inference is a new way of finding trees and tree support, in terms of probability of the topology given the data and your prior beliefs (or the default prior beliefs of your program). I use <a href="https://brahms.biology.rochester.edu/software.html">MrBayes</a> for this. Good introductions to the proper use of MrBayes (such as diagnosing convergence) can be found at Frederick Ronquist’s <a href="https://www.csit.fsu.edu/%7Eronquist/mrbayes/">site</a>.</p>
<p>Hypothesis testing</p>
<p>We often want to test our hypotheses of evolution. For example, we may ask if the tree we get from our analysis is significantly different than the traditional phylogeny, or whether the observed paraphyly of a particular group is strongly supported, or other questions. There are several ways to do this. The first step in most of them is to create a constraint tree. Open the data file in MacClade and go to the tree window. Create a random tree. Then use MacClade’s tree drawing tools to create the constraint tree. A constraint tree for the monophyly of a certain group would have only one resolved internode branch, that between the group and the rest of the taxa. A constraint tree for a previously-existing phylogenetic hypothesis would be more resolved. Export these trees from MacClade, one at a time, naming each appropriately.</p>
<p>Open PAUP and execute the data file. Under analysis, choose load constraints (don’t load as backbone constraint). Then, depending on the analysis and optimization criterion:</p>
<p><strong>For Bayesian analyses</strong>: Load the trees found after stationarity. Filter the trees to find those consistent with the constraint tree. The command for this is “filter constraint=[constraint name]”, where [constraint name] is replaced by the name of your constraint tree. Record the number of these trees. This number, divided by the total number of post-stationarity trees, is the posterior probability of the hypothesis represented by the constraint tree. For example, if 60 out of 1000 trees are left after filtering for trees with a certain group monophyletic, the probability of monophyly of this group is 6%.</p>
<p><strong>Under the parsimony criterion</strong>: Perform a thorough tree search with the constraint enforced [if using a batch file, insert “enforce=yes constraint=[constraint name]” within the hsearch command (somewhere between “hsearch” and the semicolon), replacing [constraint name] with the name of your constraint]. This generates the most parsimonious tree[s] which meet this constraint. Save these trees. Then load your most parsimonious trees found without the constraint without replacing the trees you just found [go to options in the get trees window and fill in both circles, or use “gettrees mode=7 file=[tree file name];”, replacing [tree file name] with the name of your tree file]. The Templeton and winning-sites tests are the appropriate tests to use in this situation and can be selected under Trees -&gt; Tree Scores… -&gt; Parsimony, then choosing nonparametric tests. The command for this is “pscores /nonparamtest=yes;”. The Kishino-Hasegawa test, which is also available, is inappropriate when comparing trees which were not specified <em>a priori</em>. We often report this value anyway.</p>
<p><strong>Under the likelihood criterion</strong>: Perform a thorough tree search with the constraint enforced [if using a batch file, insert “enforce=yes constraint=[constraint name]” within the hsearch command (between “hsearch” and the following semicolon), replacing [constraint name] with the name of your constraint]. This generates the likeliest tree which meets this constraint. Save this tree. Then load all likely trees without replacing the trees you just found [go to options in the get trees window and fill in both circles, or use “gettrees mode=7 file=[tree file name];”, replacing [tree file name] with the name of your tree file]. What “all likely trees” means is difficult. Some people include the maximum likelihood tree and the most parsimonious trees. You could also include all trees with a length no greater than 5 more than the most parsimonious trees or something like that. Then go to Trees -&gt; Tree Scores… -&gt; Likelihood, then click on the button for topology based tests. Choose the Shimodaira-Hasegawa test. This test measures whether some trees are better than others under likelihood. The Kishino-Hasegawa test, one many people use, is inappropriate (non-conservative) unless all the trees have been specified <em>a priori</em> (specified without using any of the data for a tree search). We often report the value anyway, though noting it’s not valid.</p>
<p>Tree drawing and editing</p>
<p>To prepare trees for publication, we use Acrobat PDF Writer. This printer extension allows trees to be saved as PDF files from PAUP, complete with correct branchlengths, scale bars, titles, and bootstrap proportions. These trees may then be opened in Adobe Illustrator and have branches colored, line thicknesses changed, keys added, etc. The trees can be saved in PDF format or output to other formats for publication.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/brianomeara\.info");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>